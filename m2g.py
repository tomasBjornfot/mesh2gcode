import numpy as np
import matplotlib.pyplot as plt
import json
import makespiral
import gcode_analyser
import pdb


# --- readers ---
def read_settings():
    """
    Reads the settings.json file
    Args:
        None
    Returns:
        All settings in a dictionary
    """
    with open('settings.json', 'r') as f:
        data = json.load(f)
    return data
def read_matrices(side):
    """
    Reads the matrices generated by the mesh2gcode program. The matrices are
    jagged and must be in a defined location.
    Args:
        side (string): The blank side. Can only be 'deck' or 'bottom'.
    Returns:
        list of np.arrays: The matrices containing the jagged matrices x, y, z.
    """
    if side == 'bottom':
        sb = 'out/bottom_'
        mx = read_jagged_matrix(sb+'mx.txt')
        my = read_jagged_matrix(sb+'my.txt')
        mz = read_jagged_matrix(sb+'mz.txt')
        zn = read_jagged_matrix(sb+'zn.txt')
    if side == 'deck':
        sd = 'out/deck_'
        mx = read_jagged_matrix(sd+'mx.txt')
        my = read_jagged_matrix(sd+'my.txt')
        mz = read_jagged_matrix(sd+'mz.txt')
        zn = read_jagged_matrix(sd+'zn.txt')
    return mx, my, mz, zn
def merge_gcodefiles(path1, path2, path3):
    """
    Merge two gcode files to a third. The file data is merged in the same 
    order.
    Args:
        path1 (string): The path for the first gcode file.
        path2 (string): The path for the second gcode file.
        path3 (string): The path for the merged gcode file.
    Returns:
        None
    """
    with open(path1, 'r') as f:
        gcode1 = f.readlines()
    with open(path2, 'r') as f:
        gcode2 = f.readlines()
    with open(path3, 'w') as f:
        gcode = gcode1 + gcode2
        for line in gcode:
            f.write(line)
def split_gcodefiles(myfiles):
    """
    Splits bottom.gc and deck.gc files in two. Also, add a start and end point a z max. 
    The second file (deck_part2.gc) starts one point before the first point ends. That
    is becaue the milling can start smoother without cutting material. The function is
    needed when milling with a small dust container that needs to be emptied in the middle
    of the milling job. The files are split to give the user a break to remove the dust in 
    the container.

    Args:
        None
    Returns:
        None
    """
    # gets the max z value
    zmax = read_settings()['HomingOffset'][2]

    for fname in myfiles:
        with open(fname+'.gc', 'r') as f:
            lines = f.readlines()
        split_index = len(lines)//2
        split_lines = []
        split_lines.append(lines[:split_index])
        split_lines.append(lines[(split_index-1):])
        
        for i in range(2):
            # makes an end point for first part
            if i == 0:
                end_line = split_lines[0][-1]
                x = end_line.split(' ')
                x_line = x[0]+' '+x[1]+' '+x[2]+' Z'+str(zmax)+' '+x[4] 
                split_lines[0].append(x_line)
            # make a start point for second part
            if i == 1:
                start_line = split_lines[1][0]
                x = start_line.split(' ')
                x_line = x[0]+' '+x[1]+' '+x[2]+' Z'+str(zmax)+' '+x[4] 
                split_lines[1] = [x_line] + split_lines[1]
            with open(fname+'_'+str(i+1)+'.gc', 'w') as f:
                for line in split_lines[i]:
                    f.write(line)
# --- from go program ---
def read_jagged_matrix(path):
    """
    Reads a jagged matrix from an ASCII text file. Jagged means that each row
    can be in a different length.
    Args:
        path (string): The path to the jagged matrix file.
    Returns:
        None  
	"""
    data = []
    with open(path, 'r') as f:
        for line in f.readlines():
            data.append([float(d) for d in line.strip().split(' ')])
    return data	
def write_jagged_matrix(data, path):
    """
    Writes a jagged matrix to file
    Args:
        data (array like): A jagged matrix.
        path (string): The path to the file.
    Returns:
        None
    """
    lines =[]
    for row in data:
        line = ''
        for item in row:
            line += str(item)+' '
        lines.append(line)
    with open(path, 'w') as f:
        [f.write(item+'\n') for item in lines]
# --- points <-> gcode ---
def points_to_gcode(points, feedrate, path):
    """
    Writes a gcode file using the input values.
    Args:
        points (array like): A nx3 matrix containing the points.
        feedate (array like): A nx1 matrix containing the feedrate.
    Returns:
        None
    """
    lines = []
    for i in range(len(points)):
        line = 'G1'
        line += ' X'+str(points[i,0])
        line += ' Y'+str(points[i,1])
        line += ' Z'+str(points[i,2])
        line += ' F'+str(feedrate[i])+'\n'
        lines.append(line)
    with open(path, 'w') as f:
        f.writelines(lines)
def points_from_gcode(path):
    """
    Extracts points and feedrate from a gcode file
    Args:
        path (string): The path to the file.
    Returns:
        np.array: The points from the gcode file    
        np.array: The feedrate from the gcode file    
    """
    points, feed = [], []
    with open(path, 'r') as f:
        for line in f.readlines():
            s = line.strip().split(' ')
            points.append([float(s[1][1:]), float(s[2][1:]), float(s[3][1:])])
            feed.append(float(s[4][1:]))
    return np.array(points), np.array(feed)
# --- analyser --- #
def point_distance(points):
    """
    Calculates the distance between adjecent points.
    Args:
        points (array like): nx3 matrix
    Returns: 
        np.array: The cartesian distance beetween points
        
    """
    dist =  np.sqrt(np.sum(np.diff(points, axis=0)**2, axis=1))
    return dist, np.sum(dist)
# --- handling of handles --- #
def add_handles(mz, handleposition, handleheight, handlewidth):
    for index in range(len(handleposition)):
        center_pos = int(handleposition[index]*len(mz)+0.5)
        start_row = center_pos - handlewidth[index]
        end_row = center_pos + handlewidth[index]
        for row in range(start_row, end_row):
            for col in range(handleheight[index]):
                mz[row][col] = mz[row][handleheight[index]+1]
    
    return mz
# --- feedrate calculations --- #
def make_angle_deviation_z_matrix(zn):
    """
    Calculates the deviation in angulation for normal vectors. The deviation
    is the vector next to the other in the matrix row. The deviation is the 
    differeance in z value. This function is used for calculation of feedrate.
    Args:
        zn (array like): The jagged matrix for normal values for the z height
    Returns:
        list: The deviation between adjecent z values:
    """
    dz = []
    for row in range(len(zn)):
        dz_row = []
        for col in range(len(zn[row])-1):
            dev = np.abs(zn[row][col] - zn[row][col+1])
            dz_row.append(np.round(180/np.pi*np.sin(dev)))
        dz_row.append(0.0)
        dz.append(dz_row)
    return dz
def make_height_deviation_z_mat(mz, mateial_height):
    """
    Calculates the deviation between the element value and material height.
    This function is used to for calculation of the feedrate.
    Args:
        mz (array like): The matrix containing the height values
        material_height (float): The material height
    Returns:
        list(list): The deviation between max height and current height
    """
    dz_height = []
    for row in range(len(mz)):
        dz_row = []
        for col in range(len(mz[row])):
            dz_row.append(np.round(mateial_height - mz[row][col]))
        dz_height.append(dz_row)
    return dz_height
def calculate_feedrate(mx, dz_angle, dz_height, max_feed, min_feed, half_feed_a, half_feed_h):
    """
    Calculates feedrate for all points in jagged matrices.
    Args:
        mx (array like): Jagged matrix containing the x values. Only used for
        know the length for each row in the matrices.
        dz_angle (list(list)): Jagged matrix containing the devations in z 
        angle. Calculated from make_angle_deviation_z_matrix function.
        max_feed (float): Sets the the maximum feedrate.
        min_feed (float): Sets the minimum feedrate.
        halv_feed_a (float): Sets at which angulation the feedrate shall be 
        half the maximum
        half_feed_h (float): Sets at which height deviation from the material
        height the feedrate shall be half the maximum
    Returns:
        list: The calculated feedrate.
    """
    fr = []
    a_const = 1.0/(2.0*half_feed_a)
    h_const = 1.0/(2.0*half_feed_h)
    for row in range(len(mx)):
        fr_row = []
        for col in range(len(mx[row])):
            
            # adapt to angle
            a_val = dz_angle[row][col]
            a_factor = a_val*a_const
            a_feed = a_factor*max_feed
            
            # adapt to milling depth
            h_val = dz_height[row][col]
            h_factor = h_val*h_const
            h_feed = h_factor*max_feed
            
            feed = max_feed - a_feed - h_feed
            if feed < min_feed:
                feed = min_feed
            fr_row.append(np.round(feed))
            
        fr.append(fr_row)
    return fr
# --- milling path and final gcode --- #
def add_start_point(points, feed, max_z, start_feed):
    """
    Adds a start point, that is a point above the first point.
    Args:
        points (array like): The points from the gcode
        feed (array like): The feedrate from the gcode
        max_z (float): The z value for the start point. Normally HomeOffset[2]
    Returns:
        np.array: The points to the gcode
        np.array: The points to the gcode
    """
    start_point = points[0, :].tolist()
    start_point[2] = max_z
    points = points.tolist()
    points.insert(0, start_point) 
    feed = [start_feed]+feed.tolist()
    return np.array(points), np.array(feed)
def add_end_point(points, feed, max_z, end_feed):
    end_point = points[-1, :].tolist()
    end_point[2] = max_z
    points = points.tolist()
    points.append(end_point)
    feed = feed.tolist()
    feed.append(end_feed)
    return np.array(points), np.array(feed)

def make_milling_points(mx, my, mz, feed):
    gx, gy, gz, fr = [], [], [], []
    max_len_cols = np.max([len(m) for m in mx])
    for col in range(max_len_cols):
    # left side
        for row in range(len(mx)):
            if col<len(mx[row])-1:
                gx.append(mx[row][col])
                gy.append(my[row][col])
                gz.append(mz[row][col])
                fr.append(feed[row][col])
        # right side
        for row in range(len(mx)):
            row2 = len(mx)-row-1
            if col<len(mx[row2])-1:
                gx.append(-mx[row2][col])
                gy.append(my[row2][col])
                gz.append(mz[row2][col])
                fr.append(feed[row2][col])
    gx = list(reversed(gx))
    gy = list(reversed(gy))
    gz = list(reversed(gz))
    fr = list(reversed(fr))
    points = np.array([gx, gy, gz]).T
    return points, np.array(fr)
def get_y_offset():
    """
    gets the min values in y direction for both deck and bottom
    """
    mxd, myd, mzd, mznd = read_matrices('deck')
    mxb, myb, mzb, mznb = read_matrices('bottom')
    return np.min([np.min(myb), np.min(myd)])

def calc(side):
    """
    Calculates the gcode for a blank side
    Args:
        side (string): an only be 'bottom' or 'deck'
    Returns:
        None. The result is written directly to file
    """
    # read settings and matrices
    s = read_settings()
    mx, my, mz, zn = read_matrices(side)
    # add handles
    mz = add_handles(mz, s['HandlePosition'], s['HandleHeight'], s['HandleWidth'])
    # calculate feedrate for the "surface milling"
    dz_angle = make_angle_deviation_z_matrix(zn)
    max_height = s['BlockThickness']/2.0 + s['ToolRadius']
    dz_height = make_height_deviation_z_mat(mz, s['BlockThickness']/2.0)
    frmax = s['FeedrateMax']
    frmin = s['FeedrateMin']
    hang = s['FeedrateHalfAngle']
    hdepth = s['FeedrateHalfDepth']
    mf = calculate_feedrate(mx, dz_angle, dz_height, frmax, frmin, hang, hdepth)
    # make points for the gcode on the surface
    points, feed = make_milling_points(mx, my, mz, mf)
    points, feed  = add_start_point(points, feed, s['HomingOffset'][2], 1500)
    points, feed  = add_end_point(points, feed, s['HomingOffset'][2], 1500)
    # offset the y dim
    y_offset = get_y_offset()
    points[:, 1] -= y_offset # ta in en parameter
    # write stuff
    points_to_gcode(points, feed, 'cam/'+side+'_surface.gc')
    write_jagged_matrix(dz_angle, 'out/'+side+'_dz_angle.txt')
    write_jagged_matrix(dz_height, 'out/'+side+'_dz_height.txt')
    write_jagged_matrix(mf, 'out/'+side+'_feedrate.txt')
    
    # spirals
    x_offset = s['Xres']/2
    feed = s['FeedrateStringer']
    step = s['StepStringer']
    if side == 'deck':
        makespiral.make_deck_spiral(x_offset, y_offset, my, mz, step, feed, max_height)
        
    if side == 'bottom':
        makespiral.make_bottom_spirals(x_offset, y_offset, my, mz, step, feed, max_height)
        path1 = 'cam/bottom_spiral_head.gc'
        path2 = 'cam/bottom_spiral_tail.gc'
        merge_gcodefiles(path1, path2, 'cam/bottom_spiral.gc')

    merge_gcodefiles('cam/'+side+'_spiral.gc', 'cam/'+side+'_surface.gc', 'cam/'+side+'.gc')
def calculate():
    """
    Merge the calculations of the top and bottom. This should be the only function used elsewhere.
    Args:
        None
    Returns:
        None
    """
    calc('deck')
    calc('bottom')
# --- MAIN --- #	
#calculate()
